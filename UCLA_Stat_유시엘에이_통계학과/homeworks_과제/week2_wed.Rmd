---
title: "Intro Programming: Flow Control"
subtitle: "Stats 102A"
author: "Miles Chen (based on Hadley Wickham and Colin Rundel)"
date: "Week 2 Wednesday"
output: ioslides_presentation
footer: Copyright Miles Chen. Please do not distribute or post without permission.
widescreen: TRUE
---
# Subsetting Wrap Up - Highlights of Subsetting applications

## Ordering (integer subsetting)

`order()` takes a vector as input and returns an integer vector describing how the subsetted vector should be ordered:

```{r}
x <- c("b", "c", "a")
order(x)
x[order(x)]
```

To break ties, you can supply additional variables to `order()`, and you can change from ascending to descending order using `decreasing = TRUE`.  By default, any missing values will be put at the end of the vector; however, you can remove them with `na.last = NA` or put at the front with `na.last = FALSE`.

## Removing columns from data frames

There are two ways to remove columns from a data frame. You can set individual columns to NULL:

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])
df$z <- NULL
```

Or you can subset to return only the columns you want:

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])
df[c("x", "y")]
```

##
If you know the columns you don't want, use set operations to work out which colums to keep:

```{r}
df[setdiff(names(df), "z")]
```

## Selecting rows based on a condition

Because it allows you to easily combine conditions from multiple columns, logical subsetting is probably the most commonly used technique for extracting rows out of a data frame. 

```{r}
mtcars[mtcars$gear == 5, ]
```

##
```{r}
mtcars[mtcars$gear == 5 & mtcars$cyl == 4, ]
```

Remember to use the vector boolean operators `&` and `|`, not the short-circuiting scalar operators `&&` and `||` which are more useful inside if statements. Don't forget De Morgan's laws, which can be useful to simplify negations:

* `!(X & Y)` is the same as `!X | !Y`
* `!(X | Y)` is the same as `!X & !Y`

For example, `!(X & !(Y | Z))` simplifies to `!X | !!(Y|Z)`, and then to `!X | Y | Z`.

##
`subset()` is a specialised shorthand function for subsetting data frames, and saves some typing because you don't need to repeat the name of the data frame.

```{r}
subset(mtcars, gear == 5)
subset(mtcars, gear == 5 & cyl == 4)
```

## Boolean algebra vs. sets

It's useful to be aware of the natural equivalence between set operations (integer subsetting) and boolean algebra (logical subsetting). Using set operations is more effective when:

* You want to find the first (or last) `TRUE`.

* You have very few `TRUE`s and very many `FALSE`s; a set representation may be faster and require less storage.

##

`which()` allows you to convert a boolean representation to an integer representation.

```{r}
x <- sample(10) < 4
x
which(x)
```

##

Let's create two logical vectors and their integer equivalents and then explore the relationship between boolean and set operations.

```{r}
(x1 <- 1:10 %% 2 == 0)
(x2 <- which(x1))
(y1 <- 1:10 %% 5 == 0)
(y2 <- which(y1))
```

##
```{r}
# X & Y <-> intersect(x, y)
x1 & y1
intersect(x2, y2)

# X | Y <-> union(x, y)
x1 | y1
union(x2, y2)
```

##
```{r}
# X & !Y <-> setdiff(x, y)
x1 & !y1
setdiff(x2, y2)

# xor(X, Y) <-> setdiff(union(x, y), intersect(x, y))
xor(x1, y1)
setdiff(union(x2, y2), intersect(x2, y2))
```

##
When first learning subsetting, a common mistake is to use `x[which(y)]` instead of `x[y]`.  Here the `which()` achieves nothing: it switches from logical to integer subsetting but the result will be exactly the same. Also beware that `x[-which(y)]` is __not__ equivalent to `x[!y]`: if `y` is all FALSE, `which(y)` will be `integer(0)` and `-integer(0)` is still `integer(0)`, so you'll get no values, instead of all values. In general, avoid switching from logical to integer subsetting unless you want, for example, the first or last `TRUE` value.


# Programming: The Basics

## Your Working Directory

When you use R, you may want to access files or output to files. Commands given to R will search the working directory.

When I open a file, I will often use the menu: Session > Set Working Directory > To Source File Location.

You can also check the working directory with `getwd()`. You can set it with `setwd("path/to/directory/")`

Note that on Windows machines, you must use a forward slash `/` or escaped backslashes `\\` to indicate the path to a directory. 

`"C:\Users\Miles\Documents"` will not work. 

`"C:/Users/Miles/Documents"` and `"C:\\Users\\Miles\\Documents"` will work.

Note: If you are working on a file with another person, you should NEVER set the working directory to something specific on your own computer.

## Checking and Clearing the environment

As you work, your environment, or workspace, will fill with objects. You can check the environment for a list of its contents with `ls()`

You can remove individual elements with `rm()`. `rm(x)` will remove the variable `x`. 

You should get in the habit of clearing out your environment whenever you start working on a new file or project. Keep in mind that whenever you render/knit a markdown file, R begins with an empty environment.

You can clear the environment this by clicking the Broom Icon in the environment panel, or by typing:

```c
rm(list = ls())  

# ls() provides a vector of all the object names in the environment. 
# rm() goes through and removes all of those names
```

##

RStudio's default settings save the current workspace when you exit and loads it when you start up. I **highly** recommend changing this option, especially if you ever plan on working on another computer or with another person. 
In the Menu: Tools > Global Options ... 

On the General tab, change the setting 'Save Worskspace to .Rdata on Exit' to 'Never'

If you ever want to save your workspace, you can do so explicitly and you will have the workspace available as a labeled file that you can transport.

## Comments in your code

Add a comment in your code with `#`

It can be useful to temporarily disable lines of code.

In R Studio, the keyboard shortcut Ctrl/Cmd + Shift + C will toggle a line to be a comment.

```{r}
# This is a comment 
x <- 3  # We assign 3 to x.
# x <- 4  # Assigning 4 to x will not be evaluated
x
```

## Writing Scripts in RStudio

It is a good idea to write code as a script in RStudio. Simply navigate the menu: File > New File > R Script.

This will create a blank plain text document (with extension .R)

Edit your commands and programs in the script. Each line or a block of highlighted text can then be executed with 'Ctrl + Enter' or 'Cmd + Enter'

If you want to run the entire script, you can enter into the console: `source("script.R")` assuming the script exists in your working directory.

## Script or Rmd?

Rmd and notebooks are very useful for creating reports or presentations that happen to include R code.

Scripts are for writing code, that might include a few comments.

If the purpose is to primarily execute a program with little need for commentary and explanation, create a script.

If you are reporting results and need to explain what is happening along the way, create an Rmd.

# Programming: Conditionals

## Logical Operators

 Operator | Vectorized?
:--------:|:----------:
  `x | y` | Yes
  `x & y` | Yes
  `!x`    | Yes
 `x || y` | No
 `x && y` | No
`xor(x,y)` | Yes

see `?base::Logic`

## Logical Conjunctions

`&` and `&&` indicate logical AND and `|` and `||` indicate logical OR.

The short form `&` and `|` are 'Vectorized,' meaning the operations perform elementwise comparisons (as well as recycling).

The 'non-vector' `||` and `&&` evaluates left to right examining only the first element of each vector. This longer form is appropriate for programming control-flow and typically preferred in if clauses.

`!` indicates logical negation (NOT).

Numeric vectors will be coerced to logical values, with zero being false and all non-zero values being true. 


##
```{r}
x <- c(TRUE,  TRUE, FALSE, FALSE,   NA,    NA)
y <- c(FALSE, TRUE, FALSE,  TRUE, TRUE, FALSE)
x | y
x & y
x || y  # only looks at first element
x && y
```

##

xor indicates elementwise exclusive OR (True if x _or_ y is true, but not if both are true). That is, `xor(TRUE, TRUE)` is `FALSE`

```{r}
x <- c(TRUE,  TRUE, FALSE, FALSE,   NA,    NA)
y <- c(FALSE, TRUE, FALSE,  TRUE, TRUE, FALSE)
xor(x, y)
```

## `any()` and `all()`

`any()` and `all()` are generalizations of OR and AND for more than 2 values.

```{r}
u <- c( TRUE,  TRUE,  TRUE) 
v <- c( TRUE,  TRUE, FALSE)
w <- c(FALSE, FALSE, FALSE)
c(any(u), any(v), any(w))
c(all(u), all(v), all(w))
```



## Comparisons

Comparison | Vectorized?
:---------:|:----------:
   `x < y` | Yes
   `x > y` | Yes
  `x <= y` | Yes
  `x >= y` | Yes
  `x == y` | Yes
  `x != y` | Yes
`x %in% y` | Yes (for `x`)

see `help(Comparison)`

## Conditional Control Flow - `if` 

Conditional execution of code blocks is achieved via `if` statements. `if` expects a length one logical vector that is not `NA`. Conditions of length greater than one are accepted with a warning, but only the first element is used. Other types are coerced to logical if possible.

Curly braces `{ }` are used to group the expression that will run if the condition inside the `if` statement is true. If there is only one expression to execute, the curly braces are optional.

##
```{r}
x <- c(1,3)
1 %in% x
if (1 %in% x)
    print("Hello!")
```


##

```{r}
x <- c(1,3)
x >= 2
if (x >= 2){  # sees only the false, does not execute
    print("Hello again!")
}
```


## 
```{r}
x <- c(1,3)
x <= 2
if (x <= 2){ ## sees only the true, and executes with a warning
    print("Hello again!")
}
```

## 
```{r}
x <- c(1,3)
any(x >= 2)  # if your logical vector has length > 1, throw it into any/all
if (any(x >= 2))
    print("Can you hear me now?")
```


## Nesting Conditionals - `if`, `else if`, and `else`

`else` statments must be used with an `if` statement and you must use the curly braces. The conditional inside an `else if` statement will only be evaluated if the starting `if` statement is `FALSE`. Make sure you put the `else` on the same line as the closing curly brace of the `if` statement, otherwise R will believe the `if` statement is complete.

```{r}
x = 3
if (x < 0) {
   print("Negative")
} else if (x > 0) {
   print("Positive")
} else {
   print("Zero")
}
```

##
```{r}
x = 0
if (x < 0) {
   print("Negative")
} else if (x > 0) {
   print("Positive")
} else {
   print("Zero")
}
```

##
```{r}
x = 3
if (x > 0) {
   print("Positive")
} else if (x > 1) {   # will not be evaluated because the first if is TRUE
   print("Bigger than 1")  
} else {
   print("Not Positive")
}
```

## Another useful conditional `ifelse`

the function `ifelse` requires three arguments:

+ a condition to test
+ the result if the condition is true
+ the result if the condition is false

```c
if(x == 5){ 
    n <- "yes"
} else {
    n <- "no"
}
```

is reduced to:

```c
n <- ifelse(x==5, "yes", "no")
```


## Loops - `for` 

Simplest, and most common type of loop in R - given a vector (including lists) iterate through the elements and evaluate the code block for each element.

```{r}
for(x in 1:10) {
  cat(x^2," ", sep="")
}
```

## 
```{r}
l = list(1:3, LETTERS[1:7], c(TRUE,FALSE))
for(y in l) {
  cat(length(y)," ",sep="")
}
```


## 

```{r}

library(datasets)
state.name[1:5]
for(state in state.name[1:5]) {
  cat(state,"has", nchar(state),"letters in it.\n")
}
```



## Loops - Storing results

It is almost always better to create an object to store your results first, rather than growing the object as you go.

```{r}
# Good
res <- rep(NA,10)
for(x in 1:10)
{
  res[x] <- x^2
}
res
```

##

```{r}
# Bad
res <- c()
for (x in 1:10)
{
  res <- c(res,x^2) # each iteration copies res into a redefined res
}
res
```

##

```{r}
# Also Bad
res <- 0
for (x in 1:10)
{
  res[x] <- x^2  # each iteration requires that res be resized
}
res
```

## Alternative loops - `while`

Repeat until the given condition is not met (FALSE)

```{r}
i <- 1
res <- rep(NA, 10)
while (i <= 10) {
  res[i] <- i ^ 2
  i <- i+1
}
res
```


## Alternative loops - `repeat`

Repeat until `break` is executed

```{r}
i <- 1
res <- rep(NA, 10)
repeat {
  res[i] <- i ^ 2
  i <- i + 1
  if (i > 10)
    break
}
res
```


## Special keywords - `break` and `next`

These are special actions that only work inside of a loop

+ `break` - ends the current (inner-most) loop
+ `next` - ends the current iteration

```{r}
for(i in 1:10) {
    if (i %% 2 == 0)
        break
    cat(i,"")
}
```

## 
```{r}
for(i in 1:10) {
    if (i %% 2 == 0)
        next
    cat(i,"")
}
```

## Back to `for` loops

Often we want to use a loop across the indexes of an object and not the elements themselves. There are several useful functions to help you do this: `:`, `seq`, `seq_along`, `seq_len`, etc.

```{r}
l = list(1:3, LETTERS[1:7], c(TRUE,FALSE))
res = rep(NA, length(l))
for(x in seq_along(l)) {
  res[x] = length(l[[x]])
}
res
```

##

```{r}
1:length(l)

seq_along(l)

seq_len(length(l))
```

