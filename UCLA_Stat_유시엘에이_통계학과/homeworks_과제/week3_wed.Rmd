---
title: "Environments"
subtitle: "Stats 102A"
author: "Miles Chen, PhD, based on work by Hadley Wickham"
date: "Week 3 Wednesday"
output: ioslides_presentation
footer: Copyright Miles Chen. Please do not distribute or post without permission.
widescreen: TRUE
---

## Scope Wrap up

*covered on Friday*

```{r}
x <- 1
y <- 1
z <- 1
f <- function(){
    y <- 2  # creates y inside the scope of f()
    g <- function(){  # this function is created inside f()
      z <- 3  # creates z inside the scope for g()
      return(x + y + z) 
      }
    return(g())
}
f()
```

##
```{r}
c(x,y,z)
```

##

*covered on Friday*

```{r}
x <- 1; y <- 1; z <- 1
f <- function(){
    y <<- 2 # assigns the value of 2 to y in the scope higher up (global)
    g <- function(){ # g() exists inside the environment of f()
      z <<- 3  # assigns the value of 3 to z in the scope higher up: f, 
               # but does not find y, so goes to the higher scope (global) 
      return(x + y + z)
      }
    return(g())
}
f()
```

##
```{r}
c(x,y,z)
```

##

*covered on Friday*

```{r}
x <- 1; y <- 1; z <- 1
f <- function(){
    y <- 2  # creates y in the current scope (inside f)
    y <<- 4 # assigns 4 directly to the higher scope y (global)
    g <- function(){
      z <<- 3  # assigns the value of 3 to z in the scope higher up: f, 
               # but does not find y, so goes to the higher scope (global) 
      return(x + y + z) # searches for y in the current scope.
                        # does not find y inside g, but does in f. Uses that value.
      }
    return(g())
}
f()  # because x = 1, y = 2 (in the scope of f), and z = 3
```

## 
```{r}
c(x,y,z) # the values of x y and z in the global environment
```


##

```{r}
x <- 1; y <- 1; z <- 1
f <- function(){
    y <- 2
    z <- 10 
    y <<- 4 # assigns 4 directly to the higher scope y
    g <- function(){
      z <<- 3 # this finds the z in the higher scope and does 
              # not touch the z in the global environment
      return(x + y + z) # uses the values in the nearest scope
      }
    return(g())
}
f()
```

##

```{r}
c(x,y,z)
```


## Avoid Super Assignment

Let's say you want to update some object 'foo'

```{r}
# BAD:
add_sq_bad <- function(foo, x){
  foo <<- c(foo, x^2)
}

foo <- 2
add_sq_bad(foo, 5)  # we call the function
foo   # this seemed to work in that foo is now updated
```

##

```{r}
# but what if we have a different object, bar
bar <- 10
add_sq_bad(bar, 5)  # we call the function again
bar  # bar is not updated

foo
```

Instead, foo is updated again. this is probably not what you wanted. The problem is that the assignment happens inside the function and is not explicitly clear when the function is called.

## 

```{r}
# GOOD:
add_sq_good <- function(baz, x){ 
  c(baz, x^2)   # no super assignment, only returns this value
}

baz <- 9
add_sq_good(baz, 5)
baz 
```

Keep in mind that calling the function only returns a new object and does not assign the value anywhere.
If you want to update a value, you must do so explicitly.

##

```{r}
foo <- 2
foo <- add_sq_good(foo, 5)  # the assignment of the output of the function to the object is explicit
foo

bar <- 10
bar <- add_sq_good(bar, 5)
bar
```


## Environments

The environment is the data structure that powers scoping.

The job of an environment is to associate, or __bind__, a set of names to a set of values. You can think of an environment as a bag of names:

![](http://i.imgur.com/ak0g5E4.png)

Imgur album: <https://imgur.com/a/ldXojQt>

##

Each name points to an object stored elsewhere in memory:

```{r}
e <- new.env()
e$a <- FALSE
e$b <- "a"
e$c <- 2.3
e$d <- 1:3
```

![](http://i.imgur.com/v0Jnui3.png)


## Parent Environments

Every environment has a parent, another environment. In diagrams, the pointer to parent is a small black circle. The parent is used to implement lexical scoping: if a name is not found in an environment, then R will look in its parent (and so on). Only one environment doesn't have a parent: the empty environment.

![](http://i.imgur.com/5miHhxb.png)

## The important environments

There are four special environments:

The `globalenv()`, or global environment, is the interactive workspace. This is the environment in which you normally work. The parent of the global environment is the last package that you attached with `library()` or `require()`.

The `baseenv()`, or base environment, is the environment of the base package. Its parent is the empty environment.

The `emptyenv()`, or empty environment, is the ultimate ancestor of all environments, and the only environment without a parent.

The `environment()` is the current environment.

## search()

search() lists all parents of the global environment. This is called the search path because objects in these environments can be found from the top-level interactive workspace. 

```{r}
search()
```

## The search path visualized

globalenv(), baseenv(), the environments on the search path, and emptyenv() are connected as shown below. Each time you load a new package with library() it is inserted between the global environment and the package that was previously at the top of the search path.

![](http://i.imgur.com/BeAWdcX.png)

## Function Environments

Most environments are created as a consequence of using functions. This section discusses the four types of environments associated with a function: enclosing, binding, execution, and calling.

The __enclosing__ environment is the environment where the function was created. Every function has one and only one enclosing environment. For the three other types of environment, there may be 0, 1, or many environments associated with each function:

- Binding a function to a name with <- defines a __binding__ environment.
- Calling a function creates an ephemeral __execution__ environment that stores variables created during execution.
- Every execution environment is associated with a __calling__ environment, which tells you where the function was called.

## The Enclosing and Binding environments

When a function is created, it gains a reference to the environment where it was made. This is the enclosing environment and is used for lexical scoping. 

When you name a function, the environment where the name exists, is the binding environment. 

In most scenarios, the enclosing environment and binding environment is the same.

## 

```{r}
y <- 1
f <- function(x) x + y
environment(f)
```

![](http://i.imgur.com/mE2nmo5.png)

function f is created in the globalenv(). So that is the enclosing environment. The name f exists in the globalenv() so it is the binding environment.

## Enclosing and Binding environments

The distinction between enclosing and binding environments is important for package namespaces. 

Package namespaces keep packages independent. For example, if package A uses the base mean() function, what happens if package B creates its own `mean()` function? Namespaces ensure that package A continues to use the base `mean()` function, and that package A is not affected by the `mean()` function in package B.

99% of the time, you probably don't have to worry about how this works, and can be confident that it does.

## Execution Environments

Each time a function is called, a new environment is created to host execution. The parent of the execution environment is the enclosing environment of the function. Once the function has completed, this environment is thrown away.

Let's look at a simple function.

```{r}
h <- function(x) {
  a <- 2
  x + a
}
y <- h(1)
```

##

<img src="http://i.imgur.com/VdxdCPe.png" height="600px" />

## Calling Environment

When you call a function, it creates an execution environment.

The execution environment has two parent environments: the enclosing environment and calling environment.

If you created a function in the globalenv() and call the function in the globalenv(), then these are the same. But in some cases, you might call a function from within another function. In this case, the enclosing environment will be the environment where the function was created, but the calling environment will be the environment from where it was called.

R's scoping rules will use the enclosing environment, so if the function is looking for values, it looks in the enclosing environment. 

However, R also supports __dynamic scoping__ where you can look for values in the calling environment.

## Scoping Quiz

```{r}
x <- 0; y <- 10
g <- function() {
  x <- 2; y <- 100
  h() # we are only calling function h inside g
}

h <- function() { # we define h in global
  x <- 3
  x + y
}
```

##

Question 1: what will h() return?

a. Error
b. 10
c. 12
d. 13
e. NA

##

```{r}
h()
```


##

Question 2: what will g() return?

a. Error
b. 10
c. 12
d. 13
e. NA

##

```{r}
g()
```

##

```{r}
x <- 0; y <- 10
j <- function() {
  x <- 2; y <- 100
  h <- function() { # we define h inside j
    x <- 50
    x + y
  }
  h() # we are only calling function h
}
```

##

Question 3: what will j() return?

a. 10
b. 60
c. 102
d. 150
e. NA

##

```{r}
j()
```

## Additional examples in the R script