---
title: "Subsetting"
author: "Hadley Wickham (edited and adapted by Miles Chen)"
date: "Week 2 Monday"
output:
  ioslides_presentation: default
  beamer_presentation: default
subtitle: Stats 102A
footer: Copyright Miles Chen. Please do not distribute or post without permission.
widescreen: yes
---

## Last time: Subsetting Atomic Vectors

- Positive Integers
- Negative Integers
- Logical Vectors
- Character Vectors

## Subsetting Lists

Subsetting a list works in the same way as subsetting an atomic vector. 

Important: Using a single square bracket `[` will always return a list. Using a double square bracket `[[` or dollar-sign `$`, as described next, let you pull out the components of the list.

## Subsetting operators

There subsetting operators: `[[ ]]` and `$` are similar to `[ ]`, except it can only return a single object and it allows you to pull pieces out of a list. `$` is a useful shorthand for `[[ ]]` combined with character subsetting.

You need `[[ ]]` when working with lists. This is because when `[ ]` is applied to a list it always returns a list: it never gives you the contents of the list. To get the contents, you need `[[ ]]`:

>  "If list `x` is a train carrying objects, then `x[[5]]` is
> the object in car 5; `x[4:6]` is a train of cars 4-6." 
>
> --- @RLangTip

##

Because it can return only a single object, you must use `[[ ]]` with either a single positive integer or a string

```{r, error = TRUE}
a <- list(x = 1:4, y = 9:6)
a[[1]]
a[["y"]] 
```

##

```{r, error = TRUE}
a[c("y","x")]   # can reference multiple elements with single bracket

```

## 

```{r, error = TRUE}
a[[c("y","x")]] # cannot reference multiple elements with double bracket

```

## 

```{r}
d <- list(a = c(1,2,3), b = c(TRUE,TRUE, FALSE), c = c("a"))
str(d)
d[1]
typeof(d[1])
```

##

```{r}
d[[1]]
typeof(d[[1]])
```

## 
```{r}
l1 <- list(1:8, letters[1:4], 5:1)  # a train of three cars
str(l1)
```

##
```{r}
l1[1] # this is a list. returns the first train car
```

##
```{r}
l1[[1]] # this is a vector. the contents of the first train car
```

##
```{r}
l1[1][2]   # this does not exist. l1[1] is a list of one item. it has no second element
l1[[1]][2] # l1[[1]] is the integer vector 1:8. The second element is 2.
```

## 
```{r}
l2 <- list( l1, c(10, 20, 30), LETTERS[4:9]) 
# l2 has 3 elements: the first is the list l1, the second and third are vectors
str(l2)
```

## 
```{r}
l2[1]    # is a list of one element: the list l1 
# (a list in a list)
str(l2[1])
```

##
```{r}
l2[[1]]  # is the contents of the first element, 
# which is the list l1 (just the listt)
str(l2[[1]])
```


##
```{r}
l2[[1]][1]
l2[[1]][1][2]
l2[[1]][[1]]
l2[[1]][[1]][2]
```

Because data frames are lists of columns, you can use `[[` to extract a column from data frames: `mtcars[[1]]`, `mtcars[["cyl"]]`.


## Subsetting Matrices and arrays

You can subset higher-dimensional structures in three ways:

* With multiple vectors. (Most common method)
* With a single vector.
* With a matrix. (least common)

The most common way of subsetting matrices (2d) and arrays (>2d) is a simple generalisation of 1d subsetting: you supply a 1d index for each dimension, separated by a comma. Blank subsetting is now useful because it lets you keep all rows or all columns.

##

```{r}
a <- matrix(1:9, nrow = 3)
colnames(a) <- c("A", "B", "C")
a
```

##

```{r}
a[1:2, ] # first and second rows
a[c(T, F, T), c("B", "A")] # first and third rows, columns b and a only
a[0, -2] # no rows, all but the second column
```

##

By default, single square bracket subsetting `[` will simplify the results to the lowest possible dimensionality. We will later discuss preservation to avoid this.

```{r}
is.vector(a) # matrix is not a vector
a[1,] # no longer a matrix
is.vector(a[1,]) # when you subset the row, it becomes a vector
```

##

Because matrices and arrays are implemented as vectors with special attributes, you can subset them with a single vector. In that case, they will behave like a vector. Arrays in R are stored in column-major order:

```{r}
(vals <- matrix(LETTERS[1:25], nrow = 5))
vals[c(8, 9)]  # select the 8th and 9th values if you treated the 
# matrix as a single atomic vector of 25 elements
```

##

You can also subset higher-dimensional data structures with an integer matrix (or, if named, a character matrix). Each row in the matrix specifies the location of one value, where each column corresponds to a dimension in the array being subsetted. This means that you use a 2 column matrix to subset a matrix, a 3 column matrix to subset a 3d array, and so on. The result is a vector of values:

```{r}
select <- matrix(ncol = 2, byrow = TRUE, c(
  1, 5,   ## select the values at the coordinates (1,5)
  3, 1,   ## value at coord (3, 1), third row, 1st col
  2, 3,
  1, 1
))
vals[select]
```

##

```{r}
# generalizes to three dimensions
(ar <- array(1:12, c(2,3,2)))
select_ar <- matrix(ncol = 3, byrow = TRUE, c(
  1,2,1,
  2,3,2))
ar[select_ar]
```


## Data frames 

Data frames possess the characteristics of both lists and matrices: if you subset with a single vector, they behave like lists; if you subset with two vectors, they behave like matrices.

```{r}
df <- data.frame(x = 1:4, y = 4:1, z = letters[1:4])
df
df[df$y %% 2 == 0, ]  # choose the rows where this logical statement is TRUE
```

##
```{r}
# Select columns like you would a list:
df[c("x", "z")]
```

##
```{r}
# select columns like a matrix
df[ , c("x", "z")]

# including or omiting the comma doesn't make a difference

```

##

```{r}
df[c(1, 3), ]  # specify the rows you want directly

```


##
```{r}
df[c(1, 3)]  # will return the first and third elements of the list
# including or omiting the comma makes a difference
```

##

There's an important difference if you select a single column: 
matrix subsetting simplifies by default, list subsetting does not.

```{r}
str(df["x"])  # remains a data frame
str(df[ , "x"])  # becomes a vector
```

## 
```{r}
str(df$x)  # becomes a vector
str(df[["x"]]) # becomes a vector
```

## What's wrong? 

```{r, error = TRUE}
mtcars[mtcars$cyl = 4, ]
```
##

```{r}
mtcars[mtcars$cyl == 4, ] # need double equal for logical test
```

## What's wrong? 

```{r, error = TRUE}
mtcars[-1:4, ] # can't mix negative with positive
```
##

```{r}
mtcars[-(1:4), ]
```

## What's wrong? 

```{r, error = TRUE}
mtcars[mtcars$cyl <= 5] # no comma. 
# The logical vector references columns. 
# It tries to add a column that does not exist
```
##

```{r}
mtcars[mtcars$cyl <= 5, ] 
# need to specify selection of rows with a comma
```

## What's wrong? 

```{r}
mtcars[mtcars$cyl == 4 | 6, ]
```
##

```{r}
# the mtcars$cyl == 4 | 6
# on the left is a logical vector
# on the right of 'or |' is the number 6 which gets coerced to TRUE,
# so it returns TRUE for everything

mtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ] 
# the or operator has to be between two logical vectors
```

## What's wrong? 

```{r, error = TRUE}
mtcars[1:20] # asks for the first 20 elements of the list
dim(mtcars)
names(mtcars)
```
##

```{r}
mtcars[1:20,] # if you don't use the comma, it will select the first 20 names
```


## Simplifying vs. preserving subsetting

It's important to understand the distinction between simplifying and preserving subsetting. 

Simplifying subsets returns the simplest possible data structure that can represent the output, and is useful interactively because it usually gives you what you want. 

Preserving subsetting keeps the structure of the output the same as the input, and is generally better for programming because the result will always be the same type. To preserve the structure, include `drop = FALSE` in the subsetting operation.

Omitting `drop = FALSE` when subsetting matrices and data frames is one of the most common sources of programming errors.

##
Unfortunately, how you switch between simplifying and preserving differs for different data types, as summarised in the table below.

|             | Simplifying               | Preserving                                   |
|-------------|---------------------------|----------------------------------------------|
| Vector      | `x[[1]]`                  | `x[1]`                                       |
| List        | `x[[1]]`                  | `x[1]`                                       |
| Factor      | `x[1:4, drop = T]`        | `x[1:4]`                                     |
| Array       | `x[1, ]` __or__ `x[, 1]`  | `x[1, , drop = F]` __or__ `x[, 1, drop = F]` |
| Data frame  | `x[, 1]` __or__ `x[[1]]`  | `x[, 1, drop = F]` __or__ `x[1]`             |

Preserving is the same for all data types: you get the same type of output as input. Simplifying behaviour varies slightly between different data types, as described on the next slides

##

*   __Atomic vector__: removes names.

    ```{r}
    x <- c(a = 1, b = 2)
    x[1]
    x[[1]]
    ```

##
*   __List__: return the object inside the list, not a single element list.

    ```{r}
    y <- list(a = 1, b = 2)
    str(y[1])
    str(y[[1]])
    ```

##
*   __Factor__: drops any unused levels.

    ```{r}
    z <- factor(c("a", "b"))
    z[1]
    z[1, drop = TRUE]
    ```

##
*   __Matrix__ or __array__: if any of the dimensions has length 1, 
    drops that dimension.

    ```{r}
    a <- matrix(1:4, nrow = 2)
    a[1, , drop = FALSE]
    a[1, ]
    ```

##
*   __Data frame__: if output is a single column, returns a vector instead of 
    a data frame.

    ```{r}
    df <- data.frame(a = 1:2, b = 1:2)
    str(df[1])
    str(df[[1]])
    ```
##
*   __Data frame (example 2)__: if output is a single column, returns a vector instead of 
    a data frame.
    ```{r}
    str(df[, "a", drop = FALSE])
    str(df[, "a"])
    ```

## `$`

`$` is a shorthand operator, where `x$y` is equivalent to `x[["y", exact = FALSE]]`.  It's often used to access variables in a data frame, as in `mtcars$cyl`.

One common mistake with `$` is to try and use it when you have the name of a column stored in a variable:

```{r}
var <- "cyl"
# Doesn't work - mtcars$var translated to mtcars[["var"]]
mtcars$var

# Instead use [[
mtcars[[var]]
```

##

There's one important difference between `$` and `[[`. `$` does partial matching:

```{r}
x <- list(abc = 1)
x$a
x[["a"]]
```

## Missing/out of bounds indices

`[` and `[[` differ slightly in their behaviour when the index is out of bounds (OOB), for example, when you try to extract the fifth element of a length four vector, or subset a vector with `NA` or `NULL`

```{r, error = TRUE}
x <- 1:4
x[5]
x[NA_real_]
x[NULL]
```

##
The following table summarises the results of subsetting atomic vectors and lists with `[` and `[[` and different types of OOB value.

| Operator and Index    | Atomic      | List          |
|-----------------------|-------------|---------------|
| `[OOB]`               | `NA`        | `list(NULL)`  |
| `[NA_real_]`          | `NA`        | `list(NULL)`  |
| `[NULL]`              | `x[0]`      | `list(NULL)`  |
| `[[OOB]]`             | Error       | Error         |
| `[[NA_real_]]`        | Error       | `NULL`        |
| `[[NULL]]`            | Error       | Error         |

If the input vector is named, then the names of OOB, missing, or `NULL` components will be `"<NA>"`.

## Subsetting and assignment

All subsetting operators can be combined with assignment to modify selected values of the input vector. 

```{r, error = TRUE}
x <- 1:5
x[c(1, 2)] <- 2:3
x

# The length of the LHS needs to match the RHS
x[-1] <- 4:1
x
```
##

```{r, error = TRUE}
# Note that there's no checking for duplicate indices
x[c(1, 1)] <- 2:3
x

# You can't combine integer indices with NA
x[c(1, NA)] <- c(1, 2)
# But you can combine logical indices with NA (where they're treated as false).
x[c(T, F, NA)] <- 1
x
```

##
```{r}
# This is most useful when conditionally modifying vectors
df <- data.frame(a = c(1, 10, NA))
df$a[df$a < 5] <- 0
df$a
```

##
Subsetting with nothing can be useful in conjunction with assignment because it will preserve the original object class and structure. Compare the following two expressions. In the first, `mtcars` will remain as a data frame. In the second, `mtcars` will become a list.

```{r, eval = FALSE}
mtcars[] <- lapply(mtcars, as.integer)
mtcars <- lapply(mtcars, as.integer)
```

##
With lists, you can use subsetting + assignment + `NULL` to remove components from a list. To add a literal `NULL` to a list, use `[ ]` and `list(NULL)`:

```{r}
x <- list(a = 1, b = 2)
x[["b"]] <- NULL
str(x)

y <- list(a = 1)
y["b"] <- list(NULL)
str(y)
```

## Applications of Subsetting

The basic principles described above give rise to a wide variety of useful applications. Some of the most important are described below. Many of these basic techniques are wrapped up into more concise functions (e.g., `subset()`, `merge()`, `plyr::arrange()`), but it is useful to understand how they are implemented with basic subsetting. This will allow you to adapt to new situations that are not dealt with by existing functions.

All credit to Hadley Wickham

## Lookup tables (character subsetting)

Character matching provides a powerful way to make lookup tables.

```{r}
x <- c("m", "f", "u", "f", "f", "m", "m")
lookup <- c(m = "Male", f = "Female", u = NA)
lookup[x]
unname(lookup[x])

# Or with fewer output values
unname(c(m = "Known", f = "Known", u = "Unknown")[x])
```

## Matching by hand (integer subsetting)

You may have a more complicated lookup table which has multiple columns of information. Suppose we have a vector of integer grades, and a table that describes their properties: 

```{r}
grades <- c(1, 2, 2, 3, 1)

info <- data.frame(
  grade = 3:1,
  desc = c("Excellent", "Good", "Poor"),
  fail = c(F, F, T)
)
```

##

We want to duplicate the info table so that we have a row for each value in `grades`. We can do this in two ways, either using `match()` and integer subsetting, or `rownames()` and character subsetting: 

```{r}
grades

# Using match
id <- match(grades, info$grade)
info[id, ]
```
##
```{r}
# Using rownames
rownames(info) <- info$grade
info[as.character(grades), ]
```

If you have multiple columns to match on, you'll need to first collapse them to a single column (with `interaction()`, `paste()`, or `plyr::id()`). 

## Random samples (integer subsetting)

You can use integer indices to perform random sampling or bootstrapping of a vector or data frame. `sample()` generates a vector of indices, then subsetting to access the values: \indexc{sample()} \index{sampling} \index{random sampling} \index{bootstrapping}

```{r}
df <- data.frame(x = rep(1:3, each = 2), y = 6:1, z = letters[1:6])
set.seed(10) # for reproducibility
# Randomly reorder
df[sample(nrow(df)), ]
```
##
```{r}
# Select 3 random rows
df[sample(nrow(df), 3), ]
```

The arguments of `sample()` control the number of samples to extract, and whether sampling is performed with or without replacement. Bootstrapping can be done by making `replace = TRUE`

## Ordering (integer subsetting) [important]

`order()` takes a vector as input and returns an integer vector describing how the subsetted vector should be ordered:

```{r}
x <- c("b", "c", "a")
order(x)
x[order(x)]
```

To break ties, you can supply additional variables to `order()`, and you can change from ascending to descending order using `decreasing = TRUE`.  By default, any missing values will be put at the end of the vector; however, you can remove them with `na.last = NA` or put at the front with `na.last = FALSE`.

##
For two or more dimensions, `order()` and integer subsetting makes it easy to order either the rows or columns of an object:

```{r}
# Randomly reorder df
df2 <- df[sample(nrow(df)), 3:1]
df2[order(df2$x), ]
df2[, order(names(df2))]
```

## Expanding aggregated counts

Sometimes you get a data frame where identical rows have been collapsed into one and a count column has been added. `rep()` and integer subsetting make it easy to uncollapse the data by subsetting with a repeated row index:

```{r}
df <- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))
rep(1:nrow(df), df$n)
df[rep(1:nrow(df), df$n), ]
```

## Removing columns from data frames [important]

There are two ways to remove columns from a data frame. You can set individual columns to NULL:

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])
df$z <- NULL
```

Or you can subset to return only the columns you want:

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])
df[c("x", "y")]
```

##
If you know the columns you don't want, use set operations to work out which colums to keep:

```{r}
df[setdiff(names(df), "z")]
```

## Selecting rows based on a condition [important]

Because it allows you to easily combine conditions from multiple columns, logical subsetting is probably the most commonly used technique for extracting rows out of a data frame. 

```{r}
mtcars[mtcars$gear == 5, ]
```

##
```{r}
mtcars[mtcars$gear == 5 & mtcars$cyl == 4, ]
```

Remember to use the vector boolean operators `&` and `|`, not the short-circuiting scalar operators `&&` and `||` which are more useful inside if statements. Don't forget De Morgan's laws, which can be useful to simplify negations:

* `!(X & Y)` is the same as `!X | !Y`
* `!(X | Y)` is the same as `!X & !Y`

For example, `!(X & !(Y | Z))` simplifies to `!X | !!(Y|Z)`, and then to `!X | Y | Z`.

##
`subset()` is a specialised shorthand function for subsetting data frames, and saves some typing because you don't need to repeat the name of the data frame.

```{r}
subset(mtcars, gear == 5)
subset(mtcars, gear == 5 & cyl == 4)
```

## Boolean algebra vs. sets

It's useful to be aware of the natural equivalence between set operations (integer subsetting) and boolean algebra (logical subsetting). Using set operations is more effective when:

* You want to find the first (or last) `TRUE`.

* You have very few `TRUE`s and very many `FALSE`s; a set representation may be faster and require less storage.

##

`which()` allows you to convert a boolean representation to an integer representation.

```{r}
x <- sample(10) < 4
x
which(x)
```

##

Let's create two logical vectors and their integer equivalents and then explore the relationship between boolean and set operations.

```{r}
(x1 <- 1:10 %% 2 == 0)
(x2 <- which(x1))
(y1 <- 1:10 %% 5 == 0)
(y2 <- which(y1))
```

##
```{r}
# X & Y <-> intersect(x, y)
x1 & y1
intersect(x2, y2)

# X | Y <-> union(x, y)
x1 | y1
union(x2, y2)
```

##
```{r}
# X & !Y <-> setdiff(x, y)
x1 & !y1
setdiff(x2, y2)

# xor(X, Y) <-> setdiff(union(x, y), intersect(x, y))
xor(x1, y1)
setdiff(union(x2, y2), intersect(x2, y2))
```

##
When first learning subsetting, a common mistake is to use `x[which(y)]` instead of `x[y]`.  Here the `which()` achieves nothing: it switches from logical to integer subsetting but the result will be exactly the same. Also beware that `x[-which(y)]` is __not__ equivalent to `x[!y]`: if `y` is all FALSE, `which(y)` will be `integer(0)` and `-integer(0)` is still `integer(0)`, so you'll get no values, instead of all values. In general, avoid switching from logical to integer subsetting unless you want, for example, the first or last `TRUE` value.
