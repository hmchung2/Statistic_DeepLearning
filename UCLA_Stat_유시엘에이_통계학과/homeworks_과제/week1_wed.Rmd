---
title: "Data Structures in R"
author: "Miles Chen"
date: "Week 1 Wednesday"
output:
  ioslides_presentation: default
subtitle: Stats 102A
widescreen: yes
---


# Data Structures in R

## Data Structures and Dimensionality

dimension|Homogeneous|Heterogeneous
:---:|:---:|:---:
1d|Atomic Vector|List (generic vector)
2d|Matrix|Data frame
nd|Array

[credit to Hadley Wickham, from whom much of this presentation draws content]

## Atomic Vectors

R has six basic atomic vector types:

typeof() | mode() | storage.mode()
-------|------|----------
logical | logical | logical
double | numeric | double
integer | numeric | integer
character | character | character
complex | complex | complex
raw | raw | raw

We'll only worry about the first four.

## Atomic Vectors

Atomic vectors are homogenous. All objects in the vector must be of the same type.

## Vector Types - Logical

Boolean values `TRUE` or `FALSE`

Always type out the whole word `TRUE` or `FALSE` in all caps. These are reserved by R to always be their logical values. R understands `T` and `F`, but values can be assigned to an object called `T`, which could cause issues if you expect `T` to mean TRUE.

```{r}
typeof(TRUE)
a <- c(FALSE, FALSE, FALSE)
typeof(a)
```

## Vector Types - Character

Character strings

```{r}
typeof("Hello")
b <- c('Adam', 'Bob', 'Chuck')
typeof(b)
```

## Vector Types - Double

Floating point numerical values (default numerical type)

```{r}
typeof(1.33)
typeof(4)
typeof(c(1,2,3))
```

## Vector Types - Integer

Integer values. Indicated with `L` after the number. Also created with the colon :

```{r}
typeof(1L)
typeof(1:3)
```

## Combining


```{r}
c(1, 2, 3)
c("Hello", "World")
c(1, c(2, 3))
```

## Testing for Types

`typeof(x)` - returns a character vector of the type of object `x`.

`is.logical(x)` - returns `TRUE` if `x` has type logical.

`is.character(x)` - returns `TRUE` if `x` has type character.

`is.double(x)` - returns `TRUE` if `x` has type double.

`is.integer(x)` - returns `TRUE` if `x` has type integer.

`is.numeric(x)` - returns `TRUE` if `x` has mode numeric. Both integer vectors and double vectors (which are often called numeric vectors) will return `TRUE`.

## Quiz 

What will each of these return? (TRUE or FALSE)

```{r, eval=FALSE}
is.integer(3)
is.integer(3:6)
is.numeric(3:6)
is.double(3:6)
```

## Answers

```{r}
is.integer(3)
is.integer(3:6)
is.numeric(3:6)
is.double(3:6)
```

## 

`is.atomic(x)` - returns `TRUE` if `x` is atomic (TRUE for atomic vectors or matrices)

`is.vector(x)` - returns `TRUE` if `x` is any type of vector (e.g. atomic vector or list).

## Coercion
R is a dynamically typed language. It converts between the various types without complaint.

```{r}
c(1,"Hello")
c(FALSE, 1L)
c(1.2, 1L)
```

## Coercion

R looks at the least restrictive form, and coerces all objects into that form.

logical (most restrictive) >> integer >> double >> character >> list (least restrictive)

```{r}
l <- c(TRUE, FALSE, TRUE)
i <- 1L
d <- c(5, 6, 7)
ch <- c("a", "b", "c")
c(l, i, d) # type double
c(l, d, ch) #type character
```

## Coercion with operators and functions

```{r}
x <- c(FALSE, FALSE, TRUE)
as.numeric(x)
# Total number of TRUEs
sum(x)

# Proportion that are TRUE
mean(x)
```

##

Coercion often happens automatically. Most mathematical functions (+, log, abs, etc.) will coerce to a double or integer, and most logical operations (&, |, any, etc) will coerce to a logical. 


## Explicit Coercion

The `is` functions also have an `as` variant which can be used for coercion.

```{r}
as.logical(5.2)
as.character(TRUE)
as.integer(pi)
```

## 
```{r}
as.numeric(FALSE)
as.double("7.2")
as.double("one")
```

## Special Values 

- `NaN` - Not a number
- `Inf` - Positive infinity
- `-Inf` - Negative infinity

These are all type double.

Be careful. Behavior not always as expected.

```{r}
pi / 0
0 / 0
```

##

```{r}
Inf + Inf
Inf + -Inf
NaN / NA
NaN * NA
```


## Missing Values

R uses `NA` to represent missing values. There are different NA for the different vector types.

```{r na1}
typeof(NA)
NA + 1
typeof(NA + 1)
```

## 

```{r na2}
NA == NA
is.na(NA)
c(4, 5, NA, 3)
typeof(NA_real_)
```

## NULL

R uses `NULL` to represent the NULL object.

```{r}
typeof(NULL)
is.null(NULL)
is.na(NULL)
```

## 

```{r}
is.logical(NULL)
NULL + FALSE
c(4, 5, NULL, 3)
```


## Quiz

What will the following output, and what is the type of each output?

```{r, eval = FALSE}
c(1, NA+1L, "C")
c(1L / 0, NA)
c(1:3, 5)
c(3L, NaN+1L)
c(NA, TRUE)
```

## 
```{r, eval = TRUE}
c(1, NA+1L, "C") ## Character
c(1L / 0, NA)
typeof(c(1L / 0, NA))
c(1:3, 5) ## double
```
##
```{r}
c(3L, NaN+1L)
typeof(c(3L, NaN+1L))
c(NA, TRUE)
typeof(c(NA, TRUE))
```


## Element-wise Operators

Many operators work element-wise. 

```{r}
1:4 + 2:5  ## 1, 2, 3, 4 + 2, 3, 4, 5
1:4 * 2:5  ## 1, 2, 3, 4 * 2, 3, 4, 5
```

## Recycling Elements

If R runs out in one vector, it recycles the elements. If there's a mismatch, it complains.

```{r}
1:4 * 2:3  ## 1, 2, 3, 4 * 2, 3, 2, 3
1:4 * 2:4  ## 1, 2, 3, 4 * 2, 3, 4, 2
```


## Lists

Lists are generic vectors, in that they are 1d and can contain any combination of R objects.

```{r}
(examp <- list("A", c(TRUE,FALSE), (1:4)/2, function(x) x^2))
```

## 
```{r}
str(examp)
```

## Recursive Lists

Lists can be nested within lists. The list will not be flat. These are called recursive lists.

```{r}
b <- list(c(5, 6), c(12, 13, 14))
c <- list(13)
a <- list(b,c)
a
```

##
```{r}
str(a)
```

##
```{r}
x <- list( list(1, 2) , c(3, 4) )
x
str(x)
```

##
```{r}
y <- c( list(1, 2) , c(3, 4) )
y
str(y)
```

## Named Lists

We can name things in lists.

```{r}
examp <- list(A = 1, B = list(C = 2, D = 3), E = c(4, 5, 6))
str(examp)
```

```{r}
examp$A
```

##
```{r}
examp$B
examp$C
examp$B$C
examp$E
```

## Attributes

Attributes are arbitrary metadata that can be attached to objects in R. Some attributes are special (e.g. class, names, dimensions) that change the way an object is handled by R.

Attributes are stored as a list attached to the object. You can access the attributes with the functions `attr()` and `attributes()`

##
```{r}
(x = c(L=1,M=2,N=3))
attributes(x)
str(attributes(x))
attr(x, "names")
```

##
```{r}
attr(x, "names") <- letters[1:3]
x
attr(x, "my_attribute") <- "This is a vector"
attributes(x)
```

## Attributes

Most attributes are lost when the vector is modified. The only attributes not lost are the three most important:

**Names**, a character vector giving each element a name.

**Dimensions**, used to turn vectors into matrices and arrays.

**Class**, used to implement R's object system.

You can access these three attributes with the following functions

```{r, eval=FALSE}
names(x)  ## instead of attr(x, "names")
dim(x)    ## instead of attr(x, "dim")
class(x)  ## instead of attr(x, "class")
```

##
```{r}
attributes(x)
attributes(x[1])
```

## Names

You can name a vector in three ways:

When creating it: `x <- c(a = 1, b = 2, c = 3)`

By modifying an existing vector in place: `x <- 1:3; names(x) <- c("a", "b", "c")`

By creating a modified copy of a vector: `y <- setNames(x, c("a", "b", "c"))`

Names don't have to be unique. However, character subsetting, is the most important reason to use names and it is most useful when the names are unique.

Not all elements of a vector need to have a name. If some names are missing, `names()` will return an empty string for those elements. If all names are missing, `names()` will return `NULL`.

## Factors

One important use of attributes is to define factors. A factor is a vector that can contain only predefined values, and is used to store categorical data. Factors are built on top of integer vectors using two attributes: the `class()`, "factor", which makes them behave differently from regular integer vectors, and the `levels()`, which defines the set of allowed values. 

```{r}
x <- factor(c("a", "b", "b", "c", "a"))
x
```

## Factors - storage modes
```{r}
class(x)
typeof(x)
levels(x)
```

## Factors
```{r}
# You can't use values that are not in the levels
x[2] <- "d"
x
```

## Factors are actually integer vectors

```{r}
print.default(x)
attributes(x)
levels(x)[3] <- "california"
x
```

## 

NB: you can't combine factors

```{r}
c(factor("a"), factor("b"))
```

##
Factors are useful when you know the possible values a variable may take, even if you don't see all values in a given data set. Using a factor instead of a character vector makes it obvious when some groups contain no observations:

```{r}
sex_char <- c("m", "m", "m")
sex_factor <- factor(sex_char, levels = c("m", "f"))

table(sex_char)
table(sex_factor)
```

## Unexpectedly factor

Sometimes when a data frame is read from a file, a column you'd thought would produce a numeric vector instead produces a factor. 

This is usually caused by a non-numeric value in the column, often a missing value encoded in a special way like `-`. To remedy the situation, coerce the vector from a factor to a character vector, and then from a character to a double vector. (Be sure to check for missing values after this process.) Of course, a much better plan is to discover what caused the problem in the first place and fix that; using the `na.strings` argument to `read.csv()` is often a good place to start.

## stringsAsFactors = BAD

Unfortunately, most data loading functions in R automatically convert character vectors to factors. This is sub-optimal, because there's no way for those functions to know the set of all possible levels or their optimal order. 

Instead, use the argument `stringsAsFactors = FALSE` to suppress this behavior, and then manually convert character vectors to factors using your knowledge of the data.

The option `as.is` performs a similar function to `stringsAsFactors` but allows for control over individual columns.

## Factors vs Characters

While factors look (and often behave) like character vectors, they are actually integers. Be careful when treating them like strings. Some string methods (like `gsub()` and `grepl()`) will coerce factors to strings, while others (like `nchar()`) will throw an error, and still others (like `c()`) will use the underlying integer values. For this reason, it's usually best to explicitly convert factors to character vectors if you need string-like behavior. In early versions of R, there was a memory advantage to using factors instead of character vectors, but this is no longer the case.


